
`section.Channel-Algebraic Grammar`
`p.
This section will briefly introduce what I call 
`q.Channel Algebra` and how it can lead to a 
theory (and practice, in a sense) of formal 
and natural-language grammar.  Channel Algebra 
is discussed in greater detail in `cite<Neustein>;.  
It's fairly divergent from other formalizations 
in computer science, though loosely decended from 
Process Algebras and from the `q.sigma calculus`/, 
which is a formal model of Object-Oriented 
programming `cite<AbadiCardelli>;.  Channel Algebra 
may also be seen as distantly related to Santanu 
Paul's `q.Source Code Algebra` `cite<SantanuPaul>; 
and to a network of discussions %-- not necessarily 
coalesced into technical publications 
%-- about how to unify Object Oriented 
and Functional Programming.  There are many 
interesting analyses presented by scientists like 
Bartosz Milewski, on web forums such as 
Milewski's blog (the address is his full name as a 
dot-com domain).  In general, 
though, I am developing Channel Algebra 
in an `q.experimental` manner, using a concrete software 
implementation in lieu of a technical or 
mathematical axiomatic description.
`p`

`p.
In the present context I want to focus on Channel Algebra as a 
potential theory in linguistic %-- particularly 
Cognitive Grammar %-- but initially I'll describe 
the underlying theory in a more computational manner.  
A lot of the Channel Algebra formalization carries 
between formal and natural languages.
`p`

`p.
A key notion in Channel Algebra is `i.procedures`/.  As in 
Part 1, we can think of procedures as either cognitive 
processes or as functions implemented in a software 
system, although for exposition the latter interpretation 
is simpler.  So, assume we have a computing environment 
where many functions are available to be 
called %-- in effect, a bundle of software libraries 
each exposing some collection of function-implementations.  
For reasons I'll cover momentarily, I'll call thse 
`i.ambient procedures`/.
`p`

`p.
At one level, Channel Algebra is conceived as an alternative 
to data-sharing paradigms like the Semantic Web; so, one 
kind of analysis is concerned with cases where some body 
of information (which can be called a `i.data set`/) 
needs to be transferred between two different 
computing environments.  Channel Algebra takes the 
view that data does not have intrinsic semantics outside 
the computational environments where it is used.  
As I argued in the context of Searle's `q.Chinese Room`/, 
our identification that a software system represents facts 
%-- like someone's full name (the example I used over several 
paragraphs in the earlier discussion) %-- depends on the 
software possessing capabilities to display the 
information (usually visually).  In other words, 
among the total of all procedures that can be performed by 
the system, only a small set of procdures are involved in 
user-interactions where semantic intentions like 
`q.this piece of data represents someone's full name` are 
relevant.
`p`

`p.
As a consequence, when sharing data that includes 
information like `i.full-name`/, we should not assume 
that the raw data, in its semantic interpretation, 
actually `q.means` `i.full-name`/, or some kind  
of propositional assertion about full names.  For 
example, a graph-edge in a Semantic Web resource 
intended to model the proposition `q.This person has full 
name Jane Doe` should not be seen as `q.meaning` anything about 
full names.  Instead, it represents some computational 
artifact which `i.becomes` an asserion of that fact 
when a procedure is eventually calld which converts 
the full name to a (usually visual) representation 
which a human user would recognize as a view 
on a full name (and hence on the proposition).
`p`

`p.
In sum, the Semantic Web (or any data sharing 
network) only `i.has` a semantics because software 
connected by the network has requisite procedures to 
make data-views that people can understand.  Data does 
not have semantics (or at least not 
human-conceptual semantics); `i.views` do.  
This is consistent with an Interface Theory: most procedures 
manipulating Semantic Web data are part of an 
interface connecting networked data sources to the 
handful of procedures which create views for human users.  
Within the local structure of this interface, data does not 
have a `q.human` semantics; instead, it must be passed around 
between proceurs before eventually 
reaching human-interaction procedures where 
(what we would call) the `q.real` 
procedures come into play. 
`p`

`p.
When data is shared btween localities, then, the procedures 
that will receive and manipulate this data are logicallly 
prior to the data itself and constrain when data-sharing is 
possible.  Without the proper network of procedures, 
the data can never be transformed into the views 
where non-local semantics are relevant.  
This motivates my choosing the term `q.`i.ambient` procedures`/, 
because a certain collection of procedures must be in place 
on the receiver end of a data-sharing event.  This also implies 
that one important role of data modeling is to indicate 
which procures a potential receiver needs to have 
available %-- i.e., needs to implement %-- to qualify as a 
capable recipient of data conforming to the model.  
Data models should describe what procedural 
capabilities must be afforded by software libraries in 
order for the human-level, conceptual semantics of 
the data can actually emerge from humans' 
interactions with the system.  
`p`

`p.
Analogous to Ontologies as data model specifications 
for the Semantic Web, I'll use the term `q.Ambient-Procedural 
Ontologies` to express the paradigm that implememting data-sharing 
protocols involves crafting software libraries around 
procedural requirements.  This has two implications for 
how we theorize software systems.  First, we need to characterize 
procedures in a manner that expresses the proceural 
capabilities that a system offers, or must have to satisfy a 
data-sharing protocol.  Second, we can assume that 
whenever data is sent, received, manipulated, or visualized, 
there is a collection of procedures available in the system 
which enact these computational processes.  
`p`

`p.
On this basis, then, I will develop a Type Theory that operationalizes 
this intuition about `q.Ambient Procedural Ontologies`/.  
The main outlines of this type theory are first that procedures 
have types; and second that procedures are `q.ambient` or 
logically prior to (or at least equiprimordial with) the 
type system itself.  This is not a mathematical type system 
where every underlying type (like Natural Numbers) and 
every operation (like arithmetic operators) have to be 
mathematically described in the theory.  
Instead, we can always take certain types and procedures as 
`q.primitive` or (at least in their inner workings) 
external to the type theory.  For any type system `tSys;, 
whose structure is regulated by a type theory we intend 
to prsent or assess, we can say that `tSys; is built 
around a `i.kernal` `kErn; of `q.primitive` 
types and functions.
`p`

`p.
In general, an assumption of Channel Algebra is that a significant 
portion of information, present in some structured system,  
can be extracted by identifying elements in 
the system with types in a suitably developd 
type system `tSys;.  In the case of Natural Language 
%-- specifically Cognitiv Grammar %-- this means that 
many syntactic and semantic details for each word 
in a sentence can be provided by mapping words to types.  
As I have mentioned, linguists like Luo and Pustejovsky 
have given persuasive analyses of certain type systems 
for `i.semantics`/, but I intend to apply 
type theory also to `i.syntax`/.  
Later in this section I will demonstrate 
this in practice, but for now 
I will hust note that such analysis requires 
a sufficiently complex type system.  For example, 
semantic notions like dot-typs and dependent-product 
typs, which have proven to be effective in shedding 
light on common lexico-semantic phenomena, may need to be 
expressible in a `tSys;, `i.along with` link- or cognitive-grammatic 
notions like `i.connectors` and `i.expectations`/.  
`p`

`p.
Similar comments apply to modeling and sharing 
scientific data.  Here, I have in mind projects 
like Conceptual Space Markup Language, and 
applications of Conceptual Spaces to study the nature 
and evolution of scientific theories, as reflected in 
research by (notably) Frank Zenker and Gregor Strle 
`cite<Zenker>;, `cite<Strle>;.  
Implicit in this research is the philosophy 
that scientific data models are not just electronic 
specifications for transmitting raw data, but embody 
scientific theories in terms of how data is structured and 
constrained.  CSML, for example, 
defines criteria on data parameters such as ranges, 
dimensions (called `q.units` in CSML), and structural 
protocols (including CSML `q.scales`/) \cite[p. 6]{RaubalAdamsCSML}.  
As a concrete example, the biomedical concept `q.blood pressure` 
is usually understood as a pair of numbers whose dimnsions ar 
each in kilopascals (kPa) and whose first number 
(systolic pressure) is necessarily greater than 
the second (diastolic) %-- technically, the pair 
is `i.monotone decreasing`/.  In conventional Biomedical 
Ontology, cf. SNOMED-CT or the Vital 
Signs Ontology, these conditions might be stipulated by 
defining a `q.blood pressure measurement` concept subject 
to the relevant dimensional and range criteria (e.g. 
diastolic pressure must be greater than zero but 
less than systolic pressure), and/or by classifying 
systolic and diastolic pressure as subconcepts of 
blood pressure (see `cite<BarrySmithBlood>; and 
`cite<AlbertGoldfain>;).  In a kind of Ontology 
paradigm incoporating type theory, the same conceptual 
structure can be represented concisely by defining 
a type whose structure conforms to the 
semantic requirements on the `i.blood pressure` concept 
as it is scientifically understood: i.e., a 
monotone-decreasing integer pair whose 
dimensional units are labeled `q.kPa` or `q.kilopascals`/.  
Note also that the `q.monotone decreasing` 
criterion is an example of the structure of 
dependent-product types (in this case because the valid range for 
the second number depends on the value of the first), 
a construction which elsewhere is used for Natural 
Language semanticcs, e.g. \cite[p. ?]{Luo}.
`p`

`p.
Th point of this example is that many scientific concepts 
%-- the semantic norms embedded in how scientific terms are defined 
and understood and how the concepts ar used in scintific theories 
and research %-- can be rigorously specified with a suitably 
expressive type system.  Therefore, a sophisticated 
system `tSys; is both a practical tool for scientific data 
sharing and scientific computing, but also an expository 
vehicle capturing theories' conceptual underpinnings.  
Developing scientifically useful type theories can 
then serve as a kind of formalized philosophy 
of science %-- type theory as metascientific analysis.
`p`

`p.
So in the past several paragraphs I have discussed the 
idea of using type attributions to represent semantic and 
syntactic details in natural language, and also 
metascientific concepts in scientific theories and data 
sharing.  A suitably developed type-system can, in light 
of these possibilities, act as a kind of multi-purpose 
tool capturing semantic principles in a broad array 
of formal and informal cotexts.  This is possible insofar as 
type theory is developed on a flexible basis so that 
type systems can expand in different directions for 
different intellectual environments %-- dependent 
sum and product types for Natural Language semantics; 
`q.connectors` for Link Grammar; CSML-style 
units, ranges, and scales for scientific data; etc.  
The overarching goal of Channel Algebra is to 
enable these flexible, multi-purpose type systems.
`p`

`p.
Another way of expressing this idea is that type systems 
should be `i.multi-paradigm`/.  Suppose we are using a 
collection of types to model the semantics of some linguistic 
or scientific model.  We may realize that ther are some 
crucial semantic formulations that need to be recognized 
within the type system itself, if this 
type-oriented modeling is to be comprehensive.  For 
esample, in a link-grammar context, we may recognize 
that, in addition to assigning semantic and/or 
Part-of-Speech types to individual words, we need to 
represent the `q.potentialities` latent in words 
allowing them to link up (each word has a `i.connectors` 
such that a pair of 
`q.compatible` connectors can produce a `q.link`/).  
Or, in a metascientific context, 
we may rcognize that we need to annotate type-attributions 
with CSML notions like range, scale, and units.  
The multi-paradigm criteria means that there would be 
a mchanism in place to enrich a type system 
`tSys; so that such semantic details can be seen as
structural parts of types modeled via `tSys;.`footnote.
I refer to `q.semantic details` even in theories of 
Natural Language `i.syntax`/, like Link Grammr, 
because many ideas about language `i.grammar` are 
relevant tobthe `i.semantics` of the linguistic 
`i.theory`/, which is different than 
the Semantics of Natural Language which linguistic 
theories have as their subject matter.
`footnote` 
`p`

`p.
One virtue of organizing a type system `tSys; around 
`i.procedures` is that this `q.multi-paradigm` 
flexibility becomes easier to achieve when we can directly 
model requirements on procedures, and how procedurs 
interact with types (for instance, each type needs 
one or more procedures to construct elements 
of that type).  As I said earlier in this section, we 
can start from any `q.kernel` of types and procedures 
and build new types by describing procedures which 
create, and/or operate on, values of 
`kErn;-types.  However, there ar many different ways that 
procedures can act on values and call other procedures.  
This means there is a lot of room for extending 
type systems to represent different kinds of inter-procedural 
relations.  For example, in Link Grammar a Part of 
Speech type is not just a `q.function` acting on 
other types %-- e.g., adjectives act on nouns; 
`q.red apple` modifies the image we have when we 
conceptualize `q.apple`/.  The adjective/noun pair also 
needs the right potentials to create a connector.  
A type-thoretic model of this idea can involve stipulating that, 
in some cases, a function-type `fFunT; is not only 
defined by the type of its argument(s), but 
by some added `q.connector` structure which must math between 
`fFunT;-instances and the instances of its argument types.
`p`

`p.
Channel Algebra, as I will now argue, 
givs us a way to encode `q.extra information` 
along these lins in type descriptions.
`p`

`subsection.Channels and Carriers`
`p.
In concvtional type theory, every type system has `i.some` notion 
of functional types, but these are often treated in a 
simple form based on Typed Lambda Calculus.  
Canonically, a function `i.inputs` 
one or more values, and `i.outputs` on or more values 
(in many concrete type systems, only on output 
value).  We can (still rather informally) 
talk of these input and output collections as 
`q.channels`/.  So, a procedure 
has an `i.input` channel %-- that's where it vgets 
its arguments from %-- and an `i.output`  
channel, where it provides a result.  The term 
`q.channel` is usually usd in the context of 
`q.process algebras` where procedurs can run concurrently, 
and channels may be two-way means of communication between 
concurrent procedures.  For this paper, I will only 
consider `i.sequential` procedurs %-- where two 
procedurs follow each other in time; no 
parallelism %-- and `i.one way` channels, which 
carry information from one procedure to another but have a fixed 
direction.  Intuitively, if `procOne; sends a value 
to `procTwo; via one channel, `procTwo; cannot send a value 
back via the same channel (although it can `i.modify` the 
value in the channel).
`p`

`p.
While type theory may conceive functions as (in effect) 
a combination of input and ouput channels, actually programming practice 
reveals multiple distinct `i.kinds` of input and output 
channels.  In Object-Oriented programming, Objects are 
passed to functions (i.e., `q.methods`/) using a 
different protocol than ordinary parameters.  Also, many 
Object-Oriented languages support Exceptions, which are like 
non-standard return values that disrupt the 
normal program flow.  This suggests two different 
`i.input` channels %-- I'll call them 
`i.lambda` and `i.sigma` for the calculii which 
can model their semantics %-- and two different 
`i.output` channeos, which I'll call `i.result` and 
`i.error`/, for normal and exceptional return values, 
respectively.  
`p`

`p.
Furthermore, many languages support `q.lambda` or `q.inline` 
functions which can be `q.closures`/, enabling a proceure 
to modify values in its `q.surrounding lexical scope`/.  In 
other words, a `i.closure` is a procedure implemented 
inside the implementation of an enclosing procedure, and 
it has the ability to read and maybe modify data used by 
the enclosing procedure.  We can consider this 
`q.handing down` of values from outer to inner 
procedures to be a kind of input channel, which 
I will call a `q.capture` channel.  Some programming languages 
make this value-sharing explicit: in the case of 
modern-day `Cpp; (since the 2011 standard) lambda 
functions have, as part of their definition, an 
explicit documentation of which symbols are 
`q.captured` from an enclosing lexical scope 
%-- these symbols are listed in square brackets, just as 
regular arguments are listed in parentheses, which 
helps reinforce the idea that inputs via 
symboo-capture are similar to inputs via argument-passing 
(which I say in Channel Alegebr as `i.lambda` and 
`i.capture` being both input channels).
`p`

`p.
Nested procedures can also be used to represent branching and 
control-flow, like `i.loop` and `i.if-then-else` 
formations.  For instance, `i.if-then-else` can be 
represented as a structure which involves two nested 
procedures: if some condition (in the outer, 
enclosing procedure) is true, then the first nested procedure 
is calld; if not, the second is called.  Similarly, a 
`i.loop` takes some nested procedure and calls it repeatedly.  
In the simplest case, the nested procedure is called again and 
again until the nested procedure returns in a manner 
that signals the loop should be brocken off (a common keyword 
for this condition, e.g. in `Cpp;, is `q.break`/).
`p`

`p.  
To demonstrate with a trivial concrete example, we 
might have pseudo-code like this:

`sentenceList,
`sentenceItem; int $x$ = 0;
`sentenceItem; loop \{
`sentenceItem; `hspace<1em>; if ($x$ > 10) break;
`sentenceItem; `hspace<1em>; ++$x$;
`sentenceItem; \} // end the loop
`sentenceList`

If we want to analyze the inner code-block as a distinct 
(but nested) procedure, we would identify how 
the nested implementation `q.captures` the $x$ value.  
We also have to identify how `i.break` causes the nested 
procedure to terminate %-- like `i.return` 
in an ordinary channel %-- but does so as a signal 
for `i.loop` (in the outer procedure) to break off.  
In effect, a nested procedure used as a loop block 
has a spcial kind of output channel which can represent two 
possible states: `i.continue` the loop or 
`i.break` the loop.  I will call this hypothetical 
channel a `i.control` channel after Chung-Chieh Shan 
`cite<ShanControl>; and Oleg Kiselyov `cite<KiselyovControl>; 
(although they work in a different underlying context).  
Most programming language runtimes don't actually 
support the more `q.exotic` channels I discuss here, 
and without runtime implementations they can 
remain as just theortical descriptions of 
programming phenomena implemented or analyzed via 
some theortical framework quite different from 
what I am calling `q.Channel Algebra`/.  
However, the data set accompanying this text 
demonstrates a runtine engine where the channel 
structures I describe here can be directly implemented.
`p`

`p.
I'll also mention the Link Grammar example, say 
an adjective as a function modifying a noun.  
In a formal model, an adjective is therefore a kind of 
`q.procedure` which inputs a noun and outputs a noun.  
In my terminology, a bread-and-butter input 
channel is called `i.lambda`/, and a bread-and-butter 
output channel is called `i.return`/.  However, Link Grammar 
also recognizes various link kinds, each driven by connector-pairs.  
For example, consider a simple link-grammatic analysis 
of adjectives in the spirit of \cite[p. 16]{SleatorTamperley}.  
Note that most nouns take adjectives, but some words we 
might want to classify as nouns don't seem to:

`sentenceList,
`sentenceItem; Today is Tuesday.
`sentenceItem; The big departmental meeting is Tuesday.
`sentenceItem; It is very windy. 
`sentenceItem; The lousy weather is very windy.
`sentenceItem; They are forecasting snow.
`sentenceItem; The latest reports are forecasting snow.
`sentenceList`

We might want to consider `i.today`/, `i.it`/, 
and `i.they` as de-facto nouns, but notic the adjctival 
constructions do not carry over: we can't say 
`q.big today`/, `q.lousy it`/, or `q.latest they`/. 
`p`

`p. 
In other words, some restriction on the `q.adjective` 
and `q.noun` types must be identified which 
blocks constructions like `q.big today` being parsed as valid 
exampls of `i.big` as an adjective type-instance.  
One option might be to define the adjective and noun 
`q.types` more narrowly, which is more in the spirit of 
type-theoretic semantics.  In that case, we 
don't take adjectives, say, as `q.functions` 
which input and output `i.any` noun, but rather 
model a suite of adjectival types operating 
on different noun types.  For example, the adjectives 
`i.salaried` and `i.elected` in 

`sentenceList,
`sentenceItem; She is a salaried employee.
`sentenceItem; He is an elected official. 
`sentenceList`

can only be attributed to persons, so qua functions 
these adjectives only `q.input` persons, as a subtype 
of nouns in gneral.  Via Link Grammmar, on the other hand, 
the basic theory involves adding extra conditions on 
the adjectives and nouns involved, which are required 
(along with the underlying type-compatibility) 
to permit the function (the adjective) to input 
the argument (the noun).   Then `i.today`/, `i.it`/, 
and `i.they` cannot take adjectivs because they do not have 
the proper `q.connectors`/.  Of course, both idas 
can be combined, so we can define 
nouns and adjectives restricted to 
narrower subtypes (like person, living 
thing, physical object, etc.) and also marked with 
connectors, so adjective-noun pairings depend on 
compatibility both at the subtype level and the 
connector level.
`p`

`p.
The important point for the current context is that 
connectors essentially extend any type system 
compatible with Link Grammar, so we need to imagine 
an extra kind of input and output channel representing 
`i.connectors` as orthogonal to underlying 
Part of Speech or lexical types.  In 
`i.big departmental meeting` we have to treat 
`i.departmental` as a kind of cognitive procedure 
modifying the concept `i.meeting`/, and then `i.big` 
as a procedure modifying the `q.output` of the first 
procedure.  Then we `i.also` have to represent a 
`i.connector` on `i.meeting` establishing that 
this conecpt/lexeme can be modified by an adjective, 
and similarly a related connector inheres to 
the `i.output` of the `q.departmental` 
procedure.  So there is a kind of output-channel 
establishing which connectors ar eavailable on procedural 
outputs (connectors of the same varieties as 
would be available on individual words), and 
special input-channels which similarly model 
connectors which must be available on 
procedural inputs.  I'll call these input-connector 
and output-connector channels.  Type-thoretic semanticists 
like Luo and Pustejovsky might prefer to 
model connectors as aspects of types themselves, but we come 
closer to capturing the Link Grammar model if we 
reprsent the connector channels as distinct from 
the regular input and output channels, whose parameter-types 
are orthogonal to the language's connector-system.  
`p`

`p.
I have, in any case, hereby prsented eight different kinds 
of channels applicable to different programming- or 
natural-language constructions: `i.lambda`/, `i.sigma`/, 
`i.capture`/, and `i.input-connector` on the input 
side; `i.return`/, `i.error`/, `i.control`/, 
and `i.output-connector` on the output side.  
`p`




`p.

`p`


