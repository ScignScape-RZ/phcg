
`section.Interface Theories: The Chinese Room Revisited`
`p.
John Searle's `q.Chinese Room` argument %-- about someone who 
behaves like he understands Chinse by matching characters to responses 
from a vast table %-- is often understood as claiming that 
`q.symbol processing` by itself can never produce real 
understanding, which is `i.semantic` and `i.conceptual`/.  
Modern technology makes this thought-experiment less 
hypothtical: automated telephone systems often use a template 
mechanism that is practically like Searle's Chinese Room, 
understanding a limited range of sentencs and producing a limited 
range of responss.  But there are two different kinds of questions we 
can ask in relation to Searle's argument: some 
more philosophical and some more practical.
`p`

`p.
On the philosophical side, we should properly assess the 
important questions as being qualitative and not 
quantitative: it's not as if a synthesized phone system 
is just not a very `i.good` conervsationalist; it's that 
a software machine simply isn't the `i.kind of thing` that 
we can say actually understands language.  This is 
plausible if we say that emotions and empathy are 
intrinsic to language; that we can't properly understand 
language if we do not grasp the emotions residing 
behind expressions.  Indeed, as the case of Grandma's window 
shows, our status as comptent interlopers depends on reading intentions 
behind expressions, and it sems hard to do this if we can't experientially 
empathize with our linguistic partners.
`p`

`p.
Maybe we are now just pushing the important questions back 
to reappear: Ok, can computers be programmed to feel emotions?  
Is there a meaningful distinction between meaningfully, 
experientially having emotions and just behaving as if 
you hav them?  Are emotions themselves somehow 
functionalizable apart from their 
chemical/hormonal substrate so that systems with very 
different physical realization than ours be said 
to have emotions?  I can see how this dbate can go 
different ways.  But I'd also argue that 
any ell-organized dialog about these questions will be 
only tangentially about language %-- in which case, 
neither linguistics nor philosophy 
of language themselves can answer questions about 
what kind of systems (on metaphysical criteria) 
actually `q.do` language.  That would imply 
that affirming a computer's linguistic capabilities 
as `i.real` linguistic understanding is a 
disciplinary non-sequitor for linguistics proper.  
Nothing in the linguist's arsenal either 
dmeonstrats or depends on AI agents actually 
`i.being` part of our linguistic community or just 
mimicking language-use to some (sometimes helpful) degree.
`p`

`p.
The more practical questions raised by Searle's 
Chinese Room come into play to the 
degree that the philosophical trail I just sketched 
turns many analyses into a non-starter.  
Consider these two questions to a hypothetical 
automated telephone service:

`sentenceList,
`sentenceItem; What time does the office open?
`sentenceItem; \label{itm:phone} What time does train 100 depart from Newark?
`sentenceList`

While we can see a template holding canned responses for both 
cases, (\ref{itm:phone}) needs to do more than just 
fit the input to the nearest pattern; it has 
to pull out the dynamically variant details 
(train `i.100` from `i.Newark`/) and use those to 
fill in details in the response.  This is something 
like `i.parsing` the original question.  So we can add 
bits and pieces of genuine linguistic processing 
to a minimal response-template system %-- a real version of 
what Searle appeared to imagine in the Room.  With enough 
added features the primitive template-driven 
kernel can evolve into a complex AI-powered 
Natural Language Processor.  
`p`

`p.
In that case we may imagine that `q.language 
understanding` exists on a spectrum.  The primitive 
telephone service and an erudite bard may lie on 
opposite ends of a spectrum, but they share a spectrum 
between them.  In this case, their differences are 
quantitative more than qualitative.  The bard just 
has more `i.features` we associate with total 
linguistic behavior.
`p`

`p.
However, this quantitative view still leaves open the question 
of where among the `q.features` do we have something 
that actually drives language competence?  Searle's 
Chinese Room helps point out these questions: 
it's reasonable to say that the simplest template-response 
system does not really understand language at all, since it 
is a pattern-matching system that does not 
have any structural relation to language itself.  
Analogous capabilities can be developed for a system 
which matches any kind of input to a pattern directing 
an output based on any 
`p`


`p.

`p`

`p.
To take a simple 
example, the fact that data about a person includes the 
field `i.full name` and, say, the value `i.Jane Doe` 
does not `i.per se` mean that this person is named 
`q.Jane Doe`/.  Rather, it means that the `q.full-name` 
value is available for a `i.procedure` which extracts the 
full-name from all information in the data set about Jane Doe.
`p`

`p.
In short, data has semantic meaning only in the context of 
procedures using the data.  This maxim suggests that we should 
revisit our conceptualization of knowledge-representation 
methods such as the Semantic Web.  In the conventional Web Ontology 
picture, information (or knowledge or facts) 
is presented as a labeled graph, where edge labels 
represent kinds of relationships.  So, one node 
may represent a person and another node a string representing her 
name; the edge-label `q.full-name` identifies the specific 
relationship assrted by that graph-edge, as compared to 
any other information that may be asserted about 
Jane Doe (her age, where she lives, her employer, etc.).  
`p`

`p.
In Channel Algebra, this `i.relational` picture is 
revised in favor of a `q.procedural` intuition.`footnote.  
The rationale at this point is similar to Spivak's 
comments in the context of Ologs (which I briefly 
mentioned earlier): `q.On the surface, ologs look the most like 
semantic networks, or concept webs, but there are important 
differences between the two notions.  First, 
arrows in a semantic network need not indicate functions; 
they can be relations.  So, [although] there is
a nice category of sets and relations [such that] 
semantic networks are categorifiable ... 
this underlying formalism does not appear to 
play a part in the study or use of semantic networks` 
\cite[p. 6]{DavidSpivak>
`footnote`  
To the degree that we do picture information as a graph, a 
label like `i.full-name` indicates that a specific 
`i.procedure` %-- whose role we can 
informally say is to tell us a person's 
full name, if we have some data structure representing 
that person %-- should be able to use the information 
in the graph (in any edge so labeled and maybe 
other edges) to fulfill its role.  So an 
edge with any given label, such as `i.full-name`/, 
actually carries two pieces of information: 
first, assuming the information in the 
graph can be properly decoded, information about 
actual attributes like a specific person's 
name; but also, information about the 
`i.requirements` for any software system to 
properly use the data in the graph.  
For examle, a `i.full-name` edge mandates 
the existence of a full-name `i.procedure` which 
can give a person's full name once we 
have a computational designation of that person.   
`p`

`p.
A related concept in Object-Oriented programmings is 
called `i.accessor` functions.  The idea of 
accessors is that, although Objects are aggregates of data 
%-- essentially, each Object is a `i.record` with multiple 
`i.fields` %-- most procedures should avoid manipulating 
Object data directly.  Instead, the class interface provides 
`q.accessor functions` which `q.wrap` access to raw data 
in function-calls.  So a `q.full-name` field might be 
wrapped in accessors called `i.getFullName` and 
`i.setFullName`/.  The basic rationale for 
this practice is that sometimes extra functionality 
should be added to examine data before it is shared 
or modified.  For example, a software library might 
be changed to represent first and last names 
separately, eliminating the `q.full-name` field.  
But the `i.getFullName` and `i.setFullName` functions could 
still be used, so long as they are re-implemented to 
transform first/last-name pairs to full names 
and vice-versa.  Software that uses the 
library will then need to `i.upgrade` the library, but 
none of `i.its own` code needs to be changed.
`p`

`p.
For these kinds of scenarioes, the basic building-blocks of 
Object-Oriented modeling tend to be `i.methods` 
%-- i.e., procedures using Objects %-- rather than raw data.  
To model information in an Object-Oriented context you 
ned to model the `i.interface` %-- the set 
of functions %-- which each class makes available.  Instead of 
`q.full name` as raw data, there are rather `i.functions` 
which get, or change, someone's full name 
(whether or not there is raw data specifically 
identifying someone's full name is considered an implementation 
detail which is deemed irrelevant to the `i.knowledge` 
provided via software using the functions).
`p`

`p.
Channel Algebra is not especially similar to 
Object-Oriented modeling, but the `q.accessor function` practice 
is a useful insight.  Effective software systems don't 
usually work by serving users accss to lots of 
raw data.  Instead, they present `i.views` 
on data, either routing data between different places or 
showing vissual (or occasionally audio) representations of data.  
So a software system dealing with someone's full name will either 
send it to some other system or visually represent it, 
for example by printing the name on a computer screen.  
In either case the software has to execute procedures: when we 
see a name printed on the screen we are not seeing 
`q.raw data`/, but rather a visual rendereing 
influenced by the language and alphabetic characters 
specific to the name, the font used to render these 
characters, the text size and color, etc.  
`p`

`p.
In sum, with this example, for most of the software 
dealing with `q.full name` data there is no actual semantic 
representation of the fact that this data represents (what we 
conceptualize as) someone's `i.full name`/.  To the degree 
that a software system includes identification of someone's 
full name, there are only a few procedures which actually 
create a view of full names that we human users would 
recognize as such.  Even seen from the extra-system, 
user-centruc, birds-eye view, it is only these procedures 
which `q.participate` in our pragmatic interpretation that 
`p`

`p.
`p`


`p.

`p`

