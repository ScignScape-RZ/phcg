`section.Procedures and Integration`
`p.
So far I have criticized paradigms which try to account for linguistic 
meaning via concordance between linguistic and proppositional 
structur; the shape of predicate complexes.   This critique has two dimnsions: 
first, although a predicate structure, a predicative specificity, does indeed 
permeate  states of affairs insofar as we engage thm rationally, such 
logical order is not modeled by language itself so much as by cognitive 
pictures we develop via interprtive processes `i.triggred` by language dtails 
but, I believe, to some not insubstantial degree pre- or xtra-linguistic.  
Moreover, second, insofar as we `i.can` decelop formal models of 
language, these are not going to be modls of prdicate structure 
in any conventional sense.  Cognitive-interpretive processes may 
have formal structure %-- structure which may even show a lot of overlap 
with propositional forms %-- but these are not `i.linguistic` structures.   
Insofar as language triggers but does not constitute interpretive 
`q.scripts`/, the scripts themselves (i.e., conceptual prototypes and 
perceptual schema we keep intelectually at hand, to interpret and 
act constructively in all situations, linguistic and otherwise) are 
not linguiatic as such %-- and neither is any propositional order they 
may simulate.  Language `i.does`/, however, structure the `i.integration` 
of `i.multiple` interpretive scripts, so the structure of this 
integration `i.is` linguistic structure per se %-- and formally 
modeling such integration can be an interesting tactic for 
formally modeling linguistic phenomena.  However, 
we should not assume that such a formal model will reemble or 
be reducible to formal logic in any useful way %-- formalization 
does not automatically entail some kind of de facto isomorphism 
to a system of logic (if not first-order then second-order, modal, etc.).  
`p`

`p.
Instead, I want to focus in on branches of computer science and 
mathematics (such a process algebra, which I have already referenced) 
as part of our scientific background insofar as the `i.structural 
integration` of diverse `q.processes` (computational processes 
in a formal sense, but perhaps analogously 
cognitive processes in a linguistic sense) can be technically represented.  
`p`

`p.
In `q.truth-theoretic` semantics, artifacts of language 
are intuitively pictured in terms of propositional structure.  
The guiding intuition compares word meanings to logical predicates; 
e.g. `q.John is married` is typically said when the speaker believes 
that, in fact, the predicate `q.married` applies to the 
speaker `q.John`/.  Switching to a more 
`q.procedural` perspective involves intuiting word-maning 
more in terms of interpretive procedures than logical predicates.  
The change in perspective may not yield substantially different 
analyses in all cases, but I believe it does affect many cases.
`p`

`p.
Even a simple predicate like `q.married` reveals a spectrum of 
not-entirely-logical cases in ordinary language:

`sentenceList,
`sentenceItem.John is married to a woman from his home country, but 
he had to get the marriag legally recognized here.` 
`sentenceItem.John married his boyfriend in Canada, but they 
live in a state that does not recognize same-sex marriages.`
`sentenceItem.John has been married for five years, but in 
many ways he's still a bachelor.`
`sentenceItem.Every married man needs a bachelor pad somewhere, 
and wherever yours is, you need a mini-fridge.`
`sentenceList`

We can make sense of these sentences because we do not conceptually 
define lexemes like `q.married` or `q.bachelor` via exhaustive 
logical rules, like `q.a bachelor is an unmarrid man`/.  Instead we 
have some combination of prototypical images %-- familiar 
characteristics of bachelors, say, which even married men 
can instantiate %-- and a conceptual framework recognizing 
(and if needed distinguishing) the various legal, societal, and 
dispositional aspects of being married.   
`p`

`p.
Intuitionwise, then, we should look beyond potential logical 
glosses on meanings %-- even when these are often accurate 
%-- and theorizee semantics as the mapping of lexical 
(as well as morphosyntactic phenomena) to interpretive scripts 
and conceptual or perceptual/enactive schema %-- which 
we can collectively designate, for sake of discussion, as 
`q.cognitive procedures`/.
`p`

`p.
The truth-theoretic mapping of words to predicates 
(and so phrasal and sentence units to propositional structures) 
provides an obvious way to formalize linguistic structur by 
borrowing the analogous structuration from 
predicate complexes.  Substituting a procedural semantic model 
allows a comparable formalization of linguistic structure 
through theories exploring procedural integration, 
for instance the interactions between computational procedures.  
Analysis of `i.computational` produres can yield interesting 
idas for linguistic theories of `i.cognitive` procdures 
%-- without endorsing a reductive metaphysics of 
cognitive procedures as `q.nothing but` computational 
procedures implemented in some sort of mental software.
`p`


`p.
The notion of computational procedures is certainly 
not foreign to symbolic logic or to analyses oftn 
associated with logistical models (in linguistics and philosophy, 
say), like Typed Lambda Calculus.  In those paradigms 
we certainly have, say, an idea of applying formulae to 
input values (where formulae can be seen as referring to or 
as compact notations for computational procedures).  Comparing 
the results of two formulae yields predicates 
(e.g., equalities or greater/less-than relations of 
quantity) that undergirds predicate systems.  Furthermore, 
combining formulae %-- plugging results of one formula 
into a free variable in another %-- yields new formulae 
that can in turn be reduced to different forms or to single 
values, either for all inputs or for particular inputs.  
In short, a large class of computational procedures can 
be modeled in predicate and equational or formula-reduction 
terms.  I point this out because shifting to 
a `q.procedural` intuitive model does not `i.by itself` 
take us outside of logistic and truth-thoretic paradigms.
`p`

`p.
In computer science, theories of procedural networks 
begin to branch out from formal logic or 
lambda calculii when we move past the `q.mathematical` 
picture of procedures %-- as computations that accept a 
collection of inputs and return a collection of outputs 
%-- and theorize procedures mor as computational 
modules that input, output, and modify values 
from multiple sources, in different ways.  In practical 
technology, this includes developments like Object-Oriented 
computer languages and programming techniques such as 
Exceptions and mutable references.  Likewise, 
real-world cod can pull information from many sources %-- like 
databases, files, and networks (including the internet) 
%-- in addition to values input as parameters to a function.   
Conversely functions have many ways to modify values 
%-- many ways to manifest side-effects %-- beyond just 
returning values as outputs.  Collectively these various 
channels of communication %-- wherein different procedures 
can exchange values in different ways %-- are often 
described as `q.inpure`/, by contrast 
to `q.pure` functions which use only a single 
input channel for (non-modifiable) input parameters 
and a single output channel. 
`p`

`p.
The design and implementation of computer programming languages 
%-- sometimes called `q.Software Language Engineering` %-- 
is partly a theoretical discipline (because programming languages 
are based on formal systems that can be studied mathematically, 
like Lambda Calculus), but also very pragmatic.  Computer languages 
are judged by practical considerations, like how efficiently they 
allow programmers to create quality software.  The impetus 
for new programming techniques often comes from the practical 
side: mainstream languages began to incoporate features like 
Object-Orientation and Exceptions (which are a mechanism to 
interrupt normal program flow when coding assumptions are violated) 
because these features proved useful to programmers.  At the same 
time, various `q.inpure` features can still be modeled at the theoretical 
level %-- there are extensions to Lambda Calculus 
with Exceptions and/or Objects, as well as `q.effect systems` that 
systematically model functional side-effects via Type Theory.  
In this case, though, the thoretical models are partly isolated or 
even lag behind the evolution of practical coding techniques.
`p`

`p.
It is also true that `q.inpure` code can always be refactored 
into a code base that uses only `q.pure` functional-programming 
techniques.  That is, at least if we exclude the `q.cyberphysical` 
layer %-- the body of code that directly measures or alteres 
physical data, like writing text to a computer screen or 
reading the position of a mouse %-- any self-contained 
collection of `q.inpure` functions can always be re-implemented 
as a system of pure `q.mathematical` functions, using 
only one-dimensional, immutable input and output channels 
(this is not necessarily true of singl functions, but 
abstractly true of complete code `i.bodies` encompassing many 
functions, i.e., many implemented procedures).  Analogously, any 
computing environment based on a type system that incorporates 
impure function-types can be recreated on top of a different 
type system that recognizes only pure functions.  For sake of 
discussion, define a `i.procedure space` as a self-contained 
network of computational procedures, where each procedure has 
the ability to invoke other procedures in the network.  We can then 
say that any procedure space developed with the benefit of 
`q.impure` coding styles (like Objects, Exceptions, and 
side-effects) is `i.computationally isomorphic` to a procdure space 
implemented exclusively in a pur-functional paradigm.
`p`

`p.
This principle might suggest that the pure/impure distinction 
is superficial, and so that any computing environment is 
actually manifesting a purely logical framework, because 
it is (in one sense) isomorphic to a structur which 
`i.can` be thoroughly modeled via formal logic.  However, this 
reductionism actually reveals the limits of `q.computational` 
isomorphism in the abstract.  Impure procedure-spaces are not 
`i.equivalent` to their pure isomorphs.  The whole rationale for 
`q.impure` coding techniques %-- Object-Orintation, functions 
with side-effects, etc. %-- is that the resulting code better 
models empirical phenomena and/or how programmers themselvs 
reason about software design.  Any notion of 
computational isomorphism which is `i.itself` prejudiced 
toward formal logic will fail to model how systems 
which are isomorphic `i.on these` (already logical) 
`i.terms` will nevertheless vary in how 
organically they model empirical and mental phenomena.  
If engineers discover that Object-Oriented paradigms 
produce more effective software for managing biomedical 
data %-- that is, biomedical concepts are usefully 
modeled in terms of semiautonomous computational `q.objects` 
whose properties and functionality are enginereed via 
many discrete, partially isolated software components %-- this 
suggests how Object-Oriented structures may be a more natural 
systematization of the underlying biomedical reality.  
Object-Oriented software can `i.in principle` be redesigned 
without Objects, but the resulting code base would thn be a weaker 
semantic `q.fit`/, a less faithful computational encoding, 
of the external information spaces that the software 
needs to modl and simulate.
`p`

`p.
I contend that this duality between Object-Oriented and 
pure-functional programming is analogous to the paradigmatic 
contrast between cognitiv and truth-theoretic semantics.  
On this analogy, pure-functional programming can be associated 
with truth-theoretic semantics in that both are founded on formal 
systems that more or less straightforwardly operationalize 
first-order logic %-- a logic with quantification and with sets 
or types modeling collections, but whose foundational units are 
boolean predicates and elementary formulae rather than 
proceures with multiple `q.channels of communication` and 
potentially many intermediate states.  Reducing impure 
(e.g., Object-Oriented) code to pure-functional procedure spaces 
is analogous to providing truth-theoretic reconstructions 
of linguistic manings, as in (revisiting examples from last section)


`sentenceList,
`sentenceItem.People fed the recused dogs (i.e.: before they 
were rescued).` 
`sentenceItem.New Yorkers vote democratic (i.e.: the majority 
of registered voters in New York do so).`
`sentenceList`

`p`

`p.

`p`


