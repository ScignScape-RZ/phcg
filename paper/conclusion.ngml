
%`vspace*<-1.5em>;
`section.Conclusion`
`p.
My analysis in this paper has focused on four 
themes: converging on a general-purpose hypergraph 
model via a standardized hypergraph serialization 
format at an Intermediate Representation level; 
generalizing hypergraphs via node, edge, and 
annotation diversification %-- in particular 
`i.procedural` hypergraphs whose hypernodes can have a 
data-collections interface, along with edge-diversification  
into channels (especially in the context of code-representation) 
and annotation-diversification into double-annotated 
edges representing carrier-transfers; 
hypergraph parsers to initialize hypergraphs with 
these extra features from source code; and 
strategies for implementing virtual machines that 
can offer an execution environment for the 
resulting hypergraphs. 
`p`

`p.
These issues are collectively illustrated in the Phaon-Graph 
format, which is a compilation-target for the demonstrated 
hypergraphs parsers and a source for generating `PGVM; code.  
Phaon-Graph spans many dimensions 
of hyper-graph modeling; last section I discussed 
double-annotations (marking carrier handoffs) and channels 
as generalizations of hyperedges (associated with 
various channel-semantic protocols).  Procedural hypernodes 
are also relevant to Phaon-Graph insofar as input source-code 
may describe instances of collections types, like 
stacks and queues %-- these data structures become represented 
in procedural hypernodes alongside the `q.tuple` hypernodes 
expressing singular source-code tokens.
`p`

`p.
The Phaon-Graph compilers and `PGVM; works on 
the assumption that `PGVM; graphs iconifying executable code 
have a specific vocabulary, and a certain set of conventions 
in terms of how modeling elements %-- compound annotations, 
channels, procedural hypernodes %-- are employed.  De facto, 
then, `PGVM; graphs have an implicit Ontology that structures the 
`PGVM; system %-- how the graph, parsing, and virtual-machine-runtime 
components are integrated together.  So far, this Ontology 
is not formally articulated %-- we do not yet have a common 
picture of how to construct `OWL;-like Ontologies for 
hypergraphs with this spectrum of extra structure.
`p`

`p.
`lPGVM; is one example that points to larger questions: 
the use-cases for general-purpose hypergraphs extend beyond 
representing (and providing a virtual-machine execution 
environment for) computer code.   
What would a general hypergraph Ontology look like?  This issue 
is partly notational %-- what would be a convenient language 
for expressing hypergraph Ontologies, by analogy to 
`OWL; being a language optimized for `RDF; Ontologies?  
More generally, though, these are questions about 
what `q.Ontology` should mean in the general hypergraph 
context.  What information should Ontologies supply 
about relevant data structures and protocols?  What kind 
of metadata and provable guarantees should a hypergraph 
Ontology add to hypergraph models as compared to those 
which are not governed by an (explicit) Ontology?
`p`

`p.
I think that Phaon-Graphs help to answer these questions because 
they are a case-study in the operational relations between 
diverse software components, whose collective functionality 
are a precondition for an effective hypergraph system.  
The overall system includes parsers to initialize hypergraphs; 
translations between different hypergraph formats 
(here, Relae-Graph to Phaon-Graph); operations for traversing 
and pulling data from hypergraphs; and generating other 
code or data structures on the basis of hypergraphs 
(here, generating `PGVMIR; code).  On this evidence, a 
general hypergraph Ontology would describe a given class 
of hypergraphs in a fashion that allows developers to plan 
out the implementations for these various facets of 
interactions with hypergraphs: parsing, intra-graph 
navigation, inter-graph Intermediate Representations, and 
the eventual output of (for example) Virtual Machine 
code, or in other contexts of data structures to be 
used by applications.  
`p`

`p.
In general, hypergraphs' greater expressivity, compared to 
other graph and/or other serialization formats, comes 
into play at two levels.  On the one hand, hypergraphs 
may capture data with greater detail and transparency.  
A hypergraph representation is not just a vehicle for 
exchanging data at a machine-readable level; potentially 
hypergraphs can describe the semantics and theoretical 
foundations of provided information with a precision 
that transcends raw digital networking.  For example, 
when hypergraphs publish scientific data, their semantic 
norms and how they use hypergraph modeling elements 
(like channels, procedural hypernodes, and 
compound annotations) can be stylized to convey 
scientific details %-- specifying empirical, experimental, 
procedural, and theoretical background, such as 
dimensions and ranges (for different quantities and 
measurements), the contrast between observed and 
calculated values (specific to a given experimental 
setup), quantitative and qualitative modeling 
assumptions, and so forth.
`p`

`p.
Meanwhile, on the other hand, hypergraph expressivity also factors 
in to the pipeline bringing shared data to user-facing applications.  
Setting aside the `q.autonomous agent` ambitions of the Semantic 
Web, most data sharing is about giving humans access to data 
which they find useful or interesting and which they might 
not discover, or benefit from, without a dedicated networking 
ecosystem.  The end-point of a typical data-sharing process is, 
then, some human user's software acquiring some new data which 
the user in turn would then view and interact with.  In the 
case of scientific data, this would entail in a typical scenario 
an application %-- perhaps special-purpose scientific software 
%-- obtaining data from (say) open-access publishers' or 
institutional repositories, and parsing the data into the 
runtime memory structures to create appropriate visuals and 
interactive components for the user's behalf.  Data describing 
chemical morphology would be routed to molecular visualization software; 
data enumerating lexemes, corpora, or parsed sentences to 
linguistics software; civic and governmental data for 
sociological and civil engineering (`q.smart cities`/) 
research, and so on.  Whereas Semantic Web practioners 
often reflect a web-development background in whose lights 
networking (and browser-based access to networked resources) 
`i.takes the place of` special-purpose applications, a 
`q.web of science` should instead conceptualize 
data networks as federations of dedicated software components 
each serving a 
distinct technical community.
`p`

`p.
Hypergraphs in this sense 
are intermediary structures whose expressivity and 
protocols should prioritize the quality and interoperability 
of application-components which, at the culmination of a 
data-sharing workflow, present new data to application users.
These models are not only preoccupied with data 
analytics and other behind-the-scenes processing; their 
value also comes to the fore from the perspective 
of application-developers working with components that 
draw data from remote sources but present the associated 
information according to application-specific protocols 
and `GUI; conventions. 
`p`

`p.
Continuing to take open-access scientific data as a case in 
point, a broad data sharing platform %-- a `q.web of 
science` %-- would therefore be engineered to 
prioritize these two dimensions.  On the one hand, 
shared data should be annotated to capture scientific 
details (theoretical and experimental models, experimental 
protocols); on the other hand, shared data should be 
targeted especially at special-purpose software that 
fits organically into scientists' working environments 
(their preferred applications, computational requirements, 
conventional data-visualizations, etc.).`footnote.
Developing precise scientific metadata standards is 
outside the scope of this paper, but there is a 
compelling community of scientists who have pressed 
for more rigorously scientific data-sharing mechanisms 
%-- including serious critiques of the Semantic Web.  
One recurring counter-tradition envisioned as a Semantic Web 
alternative derives from Conceptual Space Theory, which 
originated with work by Peter `Gardenfors; such as 
`cite<GardenforsBook>;.  This theory was extended in a 
more explicitly meta-scientific direction by `Gardenfors;' 
students or colleagues as in `cite<GardenforsZenker>; or 
`cite<GregorStrle>;.  `Gardenfors; challenges  
Semantic Web paradigms in articles like 
`cite<PeterGardenfors>; (`q.How to Make the Semantic Web 
More Semantic`/), a theme taken up by Martin Raubal 
and Benjamin Adams in `cite<RaubalAdamsMore>; 
(`q.The Semantic Web Needs More Cognition`/).  
Raubal and Adams then developed formal models and 
specifications such as Conceptual Space Markup Language 
`cite<RaubalAdamsCSML>;, `cite<RaubalAdams>;, proposals 
which certainly deserve to be revived as part of a 
hypergraph-oriented rethinking or re-engineering of the 
Semantic Web.  More recently, mathematicians such as 
David Spivak have explored Category-Theoretic 
perspectives on the Semantic Web (or its next-generation 
alternatives), e.g. `cite<SpivakKent>;, so we can 
point to multiple strands in the dialectic 
critiquing/extending `q.Semantic` technologies: scientific, 
linguistic, mathematical.  There are signs that these 
strands may be converging.  Bob Coecke and others have 
explored how to combine Conceptual Space Theory with 
hypergraph categories as in `cite<InteractingConceptualSpaces>;; 
here hypergraphs provide structural organization or syntax 
while Conceptual Spaces are the foundation for an underlying 
semantics.  I believe a hypergraph/Conceptual-Space unification 
in some fashion would be a valuable launching-point for a 
bonafide `q.more semantic` and more scientific Semantic Web.  
`footnote`  Hypergraphs 
would be a successful replacement for other (simpler) 
representations if they prove more effective at 
capturing technical metadata in the former sense and 
more conducive to programmatically fluid application-integration 
in the latter sense.
`p`

`p.
I believe, also, that a mature data-sharing platform and data-representation 
protocol, along these lines, will prioritize representations 
of procedures, algorithms, computational strategies %-- in general, 
the calculational and interface qualities of data structures 
formalized in a given scientific or technical context.  Models of 
computer code are not the only case where 
hypergraphs would have occasion to express function 
signatures, application-interface descriptions, or 
executable scripts.  Rather, the sorts of functions or 
transformations which may be applied to a data structure 
are often intrinsic features of information spaces' types and 
semantics.  Likewise, shared data may be accompanied with scripts 
that ensure the data is properly used by applications which 
acquire it. 
`p`

`p.
For these reasons, it makes sense to organize hypergraph data sharing 
platforms around hypergraph models whose representational 
capacity extends to procedural signatures and implementations.  
I would argue that the option of outputting code for a suitable 
Hypergraph Virtual Machine would then be as intrinsic to the 
`q.core` features of a hypergraph framework as the option of 
initializing hypergraphs from textual input via a parsing 
library.  The architecture around Phaon-Graph %-- linked 
to grammars via Relae-Graph, and to an execution runtime via 
the `PGVM; %-- would then be characteristic 
of a parsing an virtual-machine engine that in some fashion should 
be available to all hypergraph models. 
`p`

`p.
If this is accurate, it influences how hypergraph Ontologies 
should be conceived.  In particular, hypergraph representations 
include expressions of procedural interfaces and signatures, 
which entails the integration of programming-language 
type systems into Ontologies.  This in turn implies the 
generalization of types expressible in each Ontology to 
encompass higher-order types, function-types representative 
of semantic/syntactic features like methods 
and exceptions (which, as I have argued, may be subsumed by 
hypergraph channels), Object-Orientation, and other 
(often not-pure-functional) aspects 
of modern programming languages.   
`p`

`p.
Hypergraph Ontologies, in short, will need to draw on a wider 
pool of constructions and paradigms from programming practice and 
type theory than we have hitherto seen in contexts like the 
Semantic Web.  Potentially this very fact can make hypergraph 
representations more effective at the application-integration 
level than Semantic Web data structures and Ontologies are now. 
`p`

%`p.
%`p`

