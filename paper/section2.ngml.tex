\section{Hypergraph Parsers and Intermediate Representation}
\p{Having pointed out the features desired for a general-purpose 
hypergraph framework, the next problem is to implement a 
hypergraph library supporting these various features.  
One dimension of this problem is the proper in-memory 
representation of hypergraph structures and hypergraph elements 
(hypernodes, hyperedges, and so forth) \mdash{} to implement 
the datatypes and procedures requisite for hypergraphs as software artifacts.  
I will not emphasize these internal details directly, except for making 
implementation-related observations when relevant to other contexts 
(the accompanying code demonstrates one approach to building an 
in-memory hypergraph library, though I make no claim that the 
implementation is optimized for speed or to \q{scale up} to large 
graphs; my priority was instead to demonstrate hypergraph semantics, 
representing multiple hypergraph varieties, as expressively as possible).  
}
\p{A second stage in the implementation process, which I will 
examine here in greater detail, involves transformations 
and initialization of hypergraphs \mdash{} creating hypergraphs from 
other sources (such as text files) and using hypergraphs to 
initialize other kinds of data structures, either directly 
or indirectly (e.g., via code generators).  This dimension 
encompasses the overall capabilities allowing software to 
use hypergraphs for their own data representations 
and/or as bridge structures for sharing data between applications 
and/or components.  In bridge cases, the strategies for building 
hypergraphs \i{from} other kinds of data, and then building 
other kinds of data from hypergraphs, are equally significant 
to techniques for modeling hypergraphs themselves.
}
\p{On the \i{input} side, hypergraphs may be initialized via several 
routes.  The most direct path is to program function calls that 
can modify (and incrementally build up) hypergraphs directly.  
If hypergraphs are expressed via a cohort of \Cpp{} classes 
(for graph, node, edge, etc.), that means using \Cpp{} method 
calls to perform operations like adding a node or 
adding an edge between nodes.  Less directly, hypergraphs can 
be initialized from text files, given a standard format for 
textually encoding hypergraphs.  For conventional (non hyper-) graphs, 
standard formats include \RDF{}, \GRAPHML{}, and Notation-3.\footnote{Some graph formats support certain hypergraph features, but 
not the full spectrum of features I outlined in the last section
}  Analogous 
standards for hypergraphs would be more complex because of the 
extra structure involved.  Nevertheless, the serialization can be 
expressly organized to facilitate hypergraph initialization; 
in essence, the grammar can be standardized to unambiguously map 
test encodings to low-level function-calls via which hypergraph 
are built directly.  A still less direct input strategy would 
involve more flexible input languages, designed for ease of 
use from the point of view of people composing or reading 
serializations.  Such encodings then require more complex grammars 
and parsers for the step of mapping input test to the intended 
hypergraph structures.   
} 
   
\p{Similar alternatives apply to \i{output}, in the sense of initializing 
other structures from hypergraph data.  Output structures can be 
compiled directly via function-calls, or indirectly via software-generated 
text files, which in turn coul have a more low-level or more high-level 
format.  Suppose hypergraphs are employed within publishing 
software to generate \XML{} and \LaTeX{} output.  This can happen 
mostly at the software level: there are many \q{\XML{} builder} libraries 
allowing \XML{} documents to be constructed via function calls, rather 
than by actually producing \XML{} code.  Alternativey, the 
software can act as a code generator, expressly composing \XML{} 
or \LaTeX{} code by creating the requisite character strings 
\mdash{} a process which can be complicate by the languages' syntactic 
requirements, such as the composition of \XML{} tags and \LaTeX{} commands 
with the requisite braces and brackets.  Compared to higher-level 
markup builders, code generation can be difficult because software has 
to take responsibility for every character in the output \mdash{} every 
closing brace, bracket, quote, and so on.  In between these two 
alternatives \mdash{} using builder libraries and explicit 
code generation \mdash{} is the possibility of generating code in 
alternative formats that are optimized for machine processing, 
and consequently bypass some of the complications attending to 
generating normal (say) \XML{} or \LaTeX{}.  For instance, 
event-driven or \q{\SAX{}} parsers understand \XML{} as a sequence of 
\q{events}, like \i{open-tag}, \i{close-tag}, \i{annotation}, 
or \q{character data}.  Some projects adopt this principle to 
generate \XML{} from non-\XML{} sources (see for example 
\cite{BaltasarTrancon}, \cite{MartinWesthead}): any 
data source can be treated as an \XML{} front-end if there is a 
processor that can map the data to an \XML{} event-stream.  
On such a basis developers can design encoding languages that 
model \XML{} event-streams explicitly, as an alternative 
to normal \XML{} syntax.  Similar techniques work with 
other formats, including hypergraphs (as I will discuss below).
}
   
\p{Whatever the format, generating output from hypergraphs is closely 
tied to the issue of traversing or navigating within hypergraphs.  
In this context it is useful to consider a hypergraph as a kind 
of \q{space}, with a notion of \q{points} or \q{locations}.  
Suppose a particular graph element (hypernode, hyperedge, annotation, 
and values which may be contained in them) can be singled 
out as \q{foreground}.  Technology then needs some notation for 
moving from one foregrounded element to another \mdash{} a hypernode to 
an incident edge, or instance.  In conjunction with event-driven 
output models as mentioned last paragraph, hypergraph-traversal 
yields productive output algorithms so long as each successive 
foreground element can be mapped to one or more output events.     
}
   
\p{For this paper I will examine these and related concepts in the 
specific context of hypergraph execution engine.  Specifically, consider 
the challenge of building a programming language base on hypergraphs 
as internal representations.  In this case the input format is not 
tailored to hypergraphs, but rather to a grammar for source code which 
reflects the language's high-level paradigms (Object Orientation, 
Functional Programming, etc.).  Likewise, the output format 
is not a relatively high-level markup language like \XML{}, but rather 
something like a virtual machine or intermediate language which 
can translate to low-level (e.g., \C{} or \Cpp{}) function-calls.  
The pipeline demonstrated here also includes two different 
hypergraph formats, along with a textual serialization to marshall 
between them.  Accordingly, the system also demonstrates 
initialization of hypergraphs from a hypergraph-specific 
intermediate representation. 
}
    
\p{All told, the language engine reviewed here has a pipeline 
covering five or six steps, outlined in Figure~\ref{fig:LanguageEngine} 
\input{figLanguageEngine}.  The process begins by parsing source code (designed 
as a vaguely \C{}-like scripting language) yielding 
one style of hypergraph, with graph manipulation 
functions tied to the grammar's production rules.  
Those hypergraphs (after some preliminary analysis) are then 
traversed to produce an intermediate representation from which 
a second genre of hypergraphs is initialized, one better-suited 
for generating executable instructions.  This second 
hypergraph is then traversed in turn, outputting code in 
a special-purpose \q{virtual machine} language.  As a final step, 
this last code is then evaluated by mapping instruction to 
relatively low-level (mostly \Cpp{}) function-calls.  
}
   
\p{}  
\p{}
   
\p{}
