
`section.Hypergraph Parsers and Intermediate Representation`
`p.
Having pointed out the features desired for a general-purpose 
hypergraph framework, the next problem is to implement a 
hypergraph library supporting these various features.  
One dimension of this problem is the proper in-memory 
representation of hypergraph structures and hypergraph elements 
(hypernodes, hyperedges, and so forth) %-- to implement 
the datatypes and procedures requisite for hypergraphs as software artifacts.  
I will not emphasize these internal details directly, except for making 
implementation-related observations when relevant to other contexts 
(the accompanying code demonstrates one approach to building an 
in-memory hypergraph library, though I make no claim that the 
implementation is optimized for speed or to `q.scale up` to large 
graphs; my priority was instead to demonstrate hypergraph semantics, 
representing multiple hypergraph varieties, as expressively as possible).  
`p`

`p.
A second stage in the implementation process, which I will 
examine here in greater detail, involves transformations 
and initialization of hypergraphs %-- creating hypergraphs from 
other sources (such as text files) and using hypergraphs to 
initialize other kinds of data structures, either directly 
or indirectly (e.g., via code generators).  This dimension 
encompasses the overall capabilities allowing software to 
use hypergraphs for their own data representations 
and/or as bridge structures for sharing data between applications 
and/or components.  In bridge cases, the strategies for building 
hypergraphs `i.from` other kinds of data, and then building 
other kinds of data from hypergraphs, are equally significant 
to techniques for modelling hypergraphs themselves.
`p`

`p.
On the `i.input` side, hypergraphs may be initialized via several 
routes.  The most direct path is to program function calls that 
can modify (and incrementally build up) hypergraphs directly.  
If hypergraphs are expressed via a cohort of `Cpp; classes 
(for graph, node, edge, etc.), that means using `Cpp; method 
calls to perform operations like adding a node or 
adding an edge between nodes.  Less directly, hypergraphs can 
be initialized from text files, given a standard format for 
textually encoding hypergraphs.  For conventional (non hyper-) graphs, 
standard formats include `RDF;, `GRAPHML, and Notation-3.  Analogous 
standards for hypergraphs would be more complex because of the 
extra structure involved.  Nevertheless, the serialization can be 
expressly organized to facilitate hypergraph initialization; 
in essence, the grammar can be standardized to unambiguously map 
test encodings to low-level function-calls via which hypergraph 
are built directly.  A still less direct input strategy would 
involve more flexible input languages, designed for ease of 
use from the point of view of people composing or reading 
serializations.  Such encodings then require more complex grammars 
and parsers for the step of mapping input test to the intended 
hypergraph structures.   
`p` 

   
`p.
Similar alternatives apply to `i.output`/, 
`p`


   
`p.

`p`

   
`p.

`p`


