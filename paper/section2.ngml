
`section.Hypergraph Parsers and Intermediate Representation`
`p.
Having pointed out the features desired for a general-purpose 
hypergraph framework, the next problem is to implement a 
hypergraph library supporting these various features.  
One dimension of this problem is the proper in-memory 
representation of hypergraph structures and hypergraph elements 
(hypernodes, hyperedges, and so forth) %-- to implement 
the datatypes and procedures requisite for hypergraphs as software artifacts.  
I will not emphasize these internal details directly, except for making 
implementation-related observations when relevant to other contexts 
(the accompanying code demonstrates one approach to building an 
in-memory hypergraph library, though I make no claim that the 
implementation is optimized for speed or to `q.scale up` to large 
graphs; my priority was instead to demonstrate hypergraph semantics, 
representing multiple hypergraph varieties, as expressively as possible).  
`p`

`p.
A second stage in the implementation process, which I will 
examine here in greater detail, involves transformations 
and initialization of hypergraphs %-- creating hypergraphs from 
other sources (such as text files) and using hypergraphs to 
initialize other kinds of data structures, either directly 
or indirectly (e.g., via code generators).  This dimension 
encompasses the overall capabilities allowing software to 
use hypergraphs for their own data representations 
and/or as bridge structures for sharing data between applications 
and/or components.  In bridge cases, the strategies for building 
hypergraphs `i.from` other kinds of data, and then building 
other kinds of data from hypergraphs, are equally significant 
to techniques for modelling hypergraphs themselves.
`p`

`p.
On the `i.input` side, hypergraphs may be initialized via several 
routes.  The most direct path is to program function calls that 
can modify (and incrementally build up) hypergraphs directly.  
If hypergraphs are expressed via a cohort of `Cpp; classes 
(for graph, node, edge, etc.), that means using `Cpp; method 
calls to perform operations like adding a node or 
adding an edge between nodes.  Less directly, hypergraphs can 
be initialized from text files, given a standard format for 
textually encoding hypergraphs.  For conventional (non hyper-) graphs, 
standard formats include `RDF;, `GRAPHML, and Notation-3.`footnote.
Some graph formats support certain hypergraph features, but 
not the full spectrum of features I outlined in the last section
`footnote`  Analogous 
standards for hypergraphs would be more complex because of the 
extra structure involved.  Nevertheless, the serialization can be 
expressly organized to facilitate hypergraph initialization; 
in essence, the grammar can be standardized to unambiguously map 
test encodings to low-level function-calls via which hypergraph 
are built directly.  A still less direct input strategy would 
involve more flexible input languages, designed for ease of 
use from the point of view of people composing or reading 
serializations.  Such encodings then require more complex grammars 
and parsers for the step of mapping input test to the intended 
hypergraph structures.   
`p` 

   
`p.
Similar alternatives apply to `i.output`/, in the sense of initializing 
other structures from hypergraph data.  Output structures can be 
compiled directly via function-calls, or indirectly via software-generated 
text files, which in turn coul have a more low-level or more high-level 
format.  Suppose hypergraphs are employed within publishing 
software to generate `XML; and `Latex; output.  This can happen 
mostly at the software level: there are many `q.`XML; builder` libraries 
allowing `XML; documents to be constructed via function calls, rather 
than by actually producing `XML; code.  Alternativey, the 
software can act as a code generator, expressly composing `XML; 
or `Latex; code by creating the requisite character strings 
%-- a process which can be complicate by the languages' syntactic 
requirements, such as the composition of `XML; tags and `Latex; commands 
with the requisite braces and brackets.  Compared to higher-level 
markup builders, code generation can be difficult because software has 
to take responsibility for every character in the output %-- every 
closing brace, bracket, quote, and so on.  In between these two 
alternatives %-- using builder libraries and explicit 
code generation %-- is the possibility of generating code in 
alternative formats that are optimized for machine processing, 
and consequently bypass some of the complications attending to 
generating normal (say) `XML; or `Latex;.  

    
`p`


   
`p.

`p`

   
`p.

`p`


