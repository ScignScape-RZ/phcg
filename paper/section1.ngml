
`section.Varieties of Hypergraphs`
`p.
Any notion of hypergraphs contrasts with an 
underlying graph model, such that some element treated as 
singular or unstructurd in regular graphs becomes a multiplcity 
or compound structure in the hypergraph.  So for example, an 
edge generalizes to a hyperedge with more than two incident 
nodes (which means, for directed graphs, more than 
one source and/or target node).  Likewise, nodes might generalize 
to complex structures containing other nodes (including, 
potentially, nested graphs).  The `q.elements` of a graph 
are nodes and edges, but also (for labeled/weighted 
and/or directed graphs) things like labels, weights 
(such as probability metrics associated with edges), and directions 
(in the distinction between incoming and outgoing edges incident to each node).  
Potentially, each of these elements can be transformed 
from a simple unit to a plural structure, a process 
I will call `q.diversification`/.  That is, 
a hypergraph emerges from a graph by `q.diversifying` 
some elements, rendering as multiplicities what 
had preciously been a single entity %-- nodes become node-sets, edges 
become grouped into larger aggregates, labels generalize to 
complex structures (which we can call `q.annotations`/), 
etc.  Different avenues of diversification give 
rise to different varieties of hypergraphs, which 
I will review in the next several paragraphs.
`p`

`p.
`description,

\item[Hyperedges]  Arguably the most common model of 
hypergraphs involves generalizing edges to hyperedges, 
which (potentially) connect more than two nodes.  Directed 
hyperedges have a `q.source` node-set and a `q.target` node-set, 
either of which can (potentially) have more than one node.  
Note that this is actually a form of node-diversification 
%-- there is still (in this kind of hypergraph) just one 
edge at a time, but its incident node set (or source and 
target node-sets) are sets and not single nodes.  Another way 
of looking at directed hyperedges is to see source and target 
node-sets as integral complex parts, or `q.hypernodes`/.  
So a (directed) hypergraph with hyperedges can also 
be seen as generalizing ordinary graphs by replacing 
nodes with hypernodes.
 
\item[Recursive Graphs]  Whereas hyperedges embody a relatively 
simple node-diversification %-- nodes replaced by node-sets 
%-- so-called `q.recursive` graphs allow compound nodes (hypernodes) 
to contain entire nested graphs.  Edges in this case can still 
connect two hypernodes as in ordinary graphs, but the 
hypernodes internally contain other graphs, 
with their own nodes and edges.
 
\item[Hypergraph Categories and Link Grammar]   Since `i.labeled` 
graphs are an important model for computational models, 
we can also consider generalizations of labels to be 
compound structures rather than numeric or string labels 
(or, as in the Semantic Web, `q.predicate` terms,  
drawn from an Ontology, in `q.Subject-Predicate-Object` 
triples).  Compound labels (which I will generically call 
`q.annotations`/) are encountered (sometimes implicitly) 
in several different branches of mathematics and other fields.  
In particular, compound annotations can represent the 
rules, justifications, or `q.compatibility` which allows 
two nodes to be connected.   In this case the annotation 
may contain information about both incident nodes.  
This general phenomenon (I will mention further examples 
below) can be called a `q.diversification` 
on `i.labels`/, transforming from labels as single units 
to labels as multi-part records.

\item[Channels]   Hyperedges, which connect multiple 
nodes, are still generally seen as single edges 
(in contrast to multigraphs which allow multiple 
edges between two nodes).  Analogous to the grouping 
of nodes into hypernodes, we can also consider structures 
where several different edges are unified into a larger 
totality, which I will call a `i.channel`/.  
In the canonical case, a directed graph can group 
edges into composites (according to more fine-grained criteria 
than just distinguishing incoming and outgoing edges) which share a 
source or target node.  The set of incoming and/or outgoing  edges 
to each node may be partitioned into distinct 
`q.channels`/, so that at one scale of consideration the network 
structure can be analyzed via channels rather than via 
single edges.  For a concrete example, 
consider graphs used to model Object-Oriented programming 
languages, where a single node can represent a 
single function call.  The incoming edges are then 
`q.input parameters`/, and outgoing edges are procedural 
results or outputs.  In the Object-Oriented paradigm, however, 
input paramters are organized into two groups: in addition 
to any number of `q.conventional` arguments, there is 
a single `this; or `self; object which has a distinct  semantic 
status (`visavis; name resolution, function visibility, and 
polymorphism).  This calls, under the graph model, for splitting 
incoming edges into two `q.channels`/, one representing regular 
parameters and a separate channel for the distinguished or 
`q.receiver` object-value.
`description`
`p`

`p.
In each of these formulations, what makes a graph `q.hyper` is the presence of 
supplemental information `q.attached` to parts of an underlying (labeled, directed) 
graph.  As a concrete example, consider a case from linguistics %-- specifically, 
morphosyntactic agreement 
between gramatically linked words, which involves details 
matched between both `q.ends` of a word-to-word `q.link` 
(part-of-speech, plural/singular, gender, case/declension, 
etc.).  According to the theory known as `q.link grammar`/, 
words are associated with `q.connectors` (a related useful terminology, 
derived more in a Cognitive-Linguistic context, holds that 
words carry `q.expectations` which must be matched by other words they 
could connect to).  The word `i.many`/, for instance, as in `i.many dogs`/, 
carries an implicit expectation to be paired with a plural noun.  The actual 
syntactic connection %-- as would be embodied by a graph-edge when a graph 
formation is employed to model parse structures %-- therefore depends on 
both the expectations on one word in a pair (whichever acts as a modifier, 
like `i.many`/) and the `q.lexicomorphic` details of its `q.partner` 
(`q.dog`/, as a lexical item, being a noun, and `i.dogs` being 
in plural form).
`p`

`p.
In Link Grammar terminology, both the expectations on 
one word and the lexical and morphological state of a second are called 
`q.connectors`/; a proper linkage between two words is then a `i.connection`/.  
For each connection there is accordingly two sets of relevant information, 
which might be regarded as a generalization on edge-labeling wherein edges 
could have two or more labels.  Furthermore, the assertion of multi-part annotations 
on edges permits edges themselves to be grouped and categorized: aside from several 
dozen recognized link varieties between words (which can be seen as conventional 
edge-labels drawn from a taxonomy, consistent with ordinary labeled graphs), 
edge-annotations in this framework mark patterns of semantic and syntactic agreement 
in force between word pairs (not just foundational grammatic matching, like 
gender and number %-- singular/plural %-- but more nuanced compatibility at the 
boundary between syntax and semantics, such as the stipulation that a noun in a 
locative position must have some semantic interpretation as a place or 
destination).  Insofar as these agreement-patterns carry over to other word-pairs, 
annotations mark linguistic criteria that tie together multiple edges 
in the guise of signals that a specific parse-graph (out of the space 
of possible graphs that could be formed from a sentence's word set) is correct.
`p`


`p.
Ordinary directed graphs 
(not necessarily hypergraphs) already have some sense of grouping edges together, 
insofar as incoming and outgoing edges are distinguished; 
but this indirect association between edges does not 
internally yield a concordant grouping of the nodes 
at the sources of edges all pointing to one target node 
(or analogously the targets of one source node).  
In the theory of 
hypergraph `i.categories`/, hypernodes come into play insofar as representation 
calls for the nodes `q.across` incoming/outgoing edges to be grouped together; 
we distinguish an `i.incoming node-set` from an `i.outgoing node-set`/.  
`quote,
The term hypergraph category was introduced recently [Fon15, Kis], in reference
to the fact that these special commutative Frobenius monoids provide precisely the
structure required for their string diagrams to be directed graphs with `sq.hyperedges`/:
edges connecting any number of inputs to any number of outputs. ... 
We then think of morphisms in a hypergraph category as hyperedges 
(The Algebra of Open and
Interconnected Systems p. 13)
`quote`  

For a general mapping of  
categories to graphs where edges represent morphisms, this represents a 
generalization on the notion of `i.edges` themselves.  Suppose morphisms are 
intended to model computational procedures in a general sense (say, as 
morphisms in an ambient program state).  Because procedures can have any 
number (even zero) of both inputs and outputs, this implies a generalization 
wherein directed edges can have zero, one, or multiple source (and respectively 
target) nodes.  A corresponding hypergraph form is one where hyperedges have 
source- and target- hypernodes, but each hypernode models variant-sized sets 
of further `q.inner` nodes (or `q.hyponodes`/); here the empty set can be 
a hypernode with no hyponodes.  Elsewhere, apparently an equivalent 
structure is called a `q.trivial system`/:

`quote,
Monoidal categories admit an elegant and powerful graphical notation 
[wherin] an object $A$ is denoted by a wire [and] [a] 
morphism `fAB; is represented by a box.  The trivial system 
$I$ is the empty diagram.  Morphisms `uIA; and `vAI; 
... are referred to as `textbf.states` and `textbf.effects` 
(Interacting Conceptual Spaces I :
Grammatical Composition of Concepts, p. 4).
`quote`
`p`

`p.
The system $I$ %-- which we can also see as a hypernode with an empty 
(hypo-)node set %-- may embody a procedure which has no internal 
algorithmic or calculational structure (at least relative to the 
domain of analysis where we might represent computer code).  In 
Cyberphysical Systems, a function which just produces a 
value (with no input and no intermediate computations) can also 
be called an `i.observation`/, perhaps a direct reading from a 
physical `i.sensor` (accordingly, as in the above excerpt, a `i.state`/).  
Dually, a procedure which performs no evident calculation and produces 
no output value, but has a cyberphysical `i.effect`/, can be called an 
`q.actuation`/, potentially connected to a cyberphysical `i.actuator` 
(an example of a sensor would be a thermostat, and an example of an 
actuator would be a device which can activate/deactivate a furnace 
and/or cooling system).
`p`

`p.
In these examples I have mentioned hypergraphs in a linguistic (Link Grammar) 
a mathematical (hypergraph categories) context.  Both of these 
have some parallels insofar as a core motivation is to generalize and add 
structure to edges, either freeing edges fron constraints on 
node-arity (even allowing edges to be `q.unattached`/, 
or supplying edges with structured (potentially multi-part) annotation.
`p`

`p.
A somewhat different conception of hypergraphs is found in database 
systems such as HypergraphDB.  Graphs in that context express what have 
been called `i.recursive` graphs, wherein a hypernode `q.contains` or 
`q.designates` its own graph.  Thebasic idea is that for each (hyper-)node we 
can associate a separate (sub-)graph.  This can actually work two 
ways, yielding a distinction between (I'll say) `i.nested` 
and `i.cross-referencing` graphs.  In a `i.cross-referencing` graph, 
subgraphs or other collections of graph elements (nodes, edges, and/or 
annotations) can be given unique identifiers or designations and, as 
a data point, associated with a separate node.  Consider a case where 
nodes refer to typed values from a general-purpose type sytem; insofar 
as subgraphs themselves may be represented as typed values, a node could 
reference a subgraph by analogy to any other value (textual, numeric, 
nominal/enumerative data, etc.).  Here the (hyper)node does not 
`q.contain` but `i.references` a subgraph; the added structure involves 
subgraphs themselves being incorporated into the universe of values 
which nodes nay quantify over.  Conversely, `i.nested` hypergraphs 
model hypernodes which have other graphs `q.inside` them, thereby creating 
an ordering among nodes (we can talk of nodes at one level belonging 
to graphs which are contained in nodes at a higher level).  Such constructions 
may or may not allow edges across nodes at different levels. 
`p`


`p.
Note that nested hypergraphs can be seen as a special case of cross-referencing 
graphs, where each hypernode `nodeN; is given an index `ix;, 
with the restriction that when  `nodeN; designates (e.g. via 
its corresponding typed value) a subgraph `sg;, all of 
`sg;'s hypernodes have index `ixminusone;.  Cross-referencing 
graphs, in turn, can be seen as special cases of an overall 
space of hypergraphs wherein hypernodes are paired with 
typed values from some suitable expressive type system `tys;.  
If `tys; includes higher-order types %-- especially, lists and 
other `q.collections` types which become concrete types in 
conjunction with another type (as in `i.list` qua generic 
becomes the concrete type `i.list of integers`/), then 
hypernodes acquire aggregate structure in part by 
acquiring values whose types encompass multiple 
other values.  I will use the term `i.procedural` hypergraphs 
to discuss structures that model node diversification 
via mapping hypernodes to collections-types 
(with the possibility for hypernodes 
to `q.expand` or `q.contract` as values are inserted into or 
removed from the collection).
`p`

`p.
Cross-referencing also potentially introduces a variant derivation of 
hypergraphs which proceeds by accumulating graph elements (nodes, 
edges, and labels or annotations) into higher-scale posits, rather 
than defining inner structures on elements.  Specifically, as a 
complimentary operation to diversification, consider `q.aggregation` 
of graph elements: the option to take a set of (hyper)nodes, 
(hyper)edges, and/or annotations as a typed value which can then 
be assigned to a (hyper)node.  In such a manner, higher-level 
structures can be notated with respect to graphs, which is one 
way to model phenomena such as `i.contexts` %-- the kind of multi-scale 
patterns that are considered endemic to practical domains 
like the Semantic Web.  While it is informally acknowledged that 
a single-level interpretation of the Semantic Web is misleading 
%-- the Semantic Web is not an undifferentiated mesh of connections, but 
rather an aggregation of data from many sources, which implies the existence of 
localization, contextualization, and other `q.emergent` structure %-- 
there is no defininitive protocol for actually representing this emergenet 
structure.  This issue, in turn, is one of arguments 
for hypergraphs in lieu of ordinary graphs as general-purpose 
data representations. 
`p`



